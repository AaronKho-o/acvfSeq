---
title: "acvfSeq"
author: "Aaron Khoo"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{acvfSeq}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(acvfSeq)
```


**Overview**

Since all symmetric positive semidefinite sequences can serve as the autocovariance function of a weakly stationary process, the tools in infinite time series analysis are used to determine if a symmetric sequence is positive semidefinite. 


**Approach 1: Time Domain**

In the time domain, a symmetric sequence can be shown to be positive semidefinite if all of its corresponding toeplitz matrices are also positive semidefinite. However, at some point, an infinite sequence might have value zero for all future points. The function tmatrix_psd() is designed to test this kind of sequence. Given the values of a sequence, it assumes the rest of the sequence has value zero. It generates toeplitz matrices up till the specified dimension n and checks if each of them are not positive semidefinite. The function only accepts sequences of at least length 2.

*Function:* tmatrix_psd(n, s)

*Example* 

Suppose a sequence symmetric about point 0 is defined on discrete and integer points such that $f(0) = 1$, $f(1) = 2$ and $f(x) = 0$ for all $|x| >= 2$. Then s = c(1, 2). Suppose we want to test up to the 100 dimension toeplitz matrix generated by the sequence, then n = 100. 

```{r echo = T, results = 'hide'}
tmatrix_psd(100, c(1,2))
```

*Remarks*

The function assumes infinite time series points. This means n can go up to any integer, but comes with the cost of increased runtime. It is testing if the sequence is not positive semidefinite and returns the dimensions of the corresponding toeplitz matrix where this is the case. It returns -1 if it cannot determine the result.

The approach described above is limited by the value of n. The tmatrix_psd() function cannot identify a positive semidefinite sequence; it can only prove sequences are not. For this, it is useful to approach this problem in the frequency domain. 


**Approach 2: Frequency Domain**

The spectral density f() of a weakly stationary process given its autocovariance function a() is defined as: 

$$f(w) = \sum_{h=-\infty}^{h=\infty}a(h)*e^{-2iwh\pi}$$
In particular, $f(w) >= 0$ for all $w \in [-0.5, 0.5]$ This corresponds to the positive semidefinite condition of the autocovariance function of a stationary process. It is much easier to test if f(w) is negative for a certain value of w in the range specified. The functions that correspond to this method are listed below:

1. spec_density()
2. spec_density_plot()

*Function:* spec_density(s, lowerBound, upperBound, step = 0.1)

*Example*

Consider the same sequence as in the time domain. Suppose the frequencies of the spectral density to be calculated are {-0.5, -0.3, -0.1, 0.1, 0.3, 0.5}. spec_density() returns a vector of these values.

```{r echo = T, results = 'hide'}
spec_density(c(1,2), -0.5, 0.5, step = 0.2)
```

*Function:* spec_density_plot(s, lowerBound, upperBound, step = 0.1)

*Example*

Using the same example above, spec_density_plot() returns the plotted values of the spec_density() vector.

```{r echo = T, results = 'hide', fig.show ='hide'}
spec_density_plot(c(1,2), -0.5, 0.5, step = 0.2)
```

*Remarks*

The lower and upper bounds can be specified for any range of w.

**Other functions**

*Function:* convert_complex_exp(z)

*Example*

Consider 4-8i. convert_complex_exp() will return a vector containing its magnitude and angle corresponding to its exponential form.

```{r echo = T, results = 'hide'}
convert_complex_exp(4-8i)
```




